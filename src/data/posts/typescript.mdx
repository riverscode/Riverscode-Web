---
title: "Un viaje a trav√©s de TypeScript"
summary: "Descubre los conceptos esenciales de TypeScript y ejemplos pr√°cticos en este completo post. Aprende a potenciar tu c√≥digo JavaScript con tipado est√°tico y caracter√≠sticas avanzadas. Perfecto para principiantes y desarrolladores experimentados."
cover: "https://res.cloudinary.com/lambda-ingenier-a-e-innovaci-n/image/upload/v1665983632/blog-Riverscode/Asincronismo-portada_dp7jbz.png"
author: "Rivers Code"
publishedAt: "2023-06-25"
image: "typescript.webp"
tags:
  - üíô Typescript"
status: "ready"
---


En el apasionante mundo del desarrollo web, TypeScript se ha convertido en una herramienta imprescindible para llevar nuestro c√≥digo JavaScript al siguiente nivel. ¬øQu√© es TypeScript? Es un lenguaje de programaci√≥n que se basa en JavaScript y agrega el poder del tipado est√°tico y otras caracter√≠sticas avanzadas. En este post, exploraremos a fondo TypeScript, desde sus conceptos fundamentales hasta t√©cnicas m√°s avanzadas, para que puedas aprovechar al m√°ximo esta poderosa herramienta.

¬øPor qu√© TypeScript se ha vuelto tan popular? Los beneficios son claros: el tipado est√°tico nos ayuda a detectar errores en tiempo de compilaci√≥n, mejorar la calidad del c√≥digo y facilitar el mantenimiento a largo plazo. Adem√°s, TypeScript nos brinda un conjunto de caracter√≠sticas adicionales, como las interfaces, las clases y los m√≥dulos, que nos permiten escribir c√≥digo m√°s estructurado y modular.

En este post, nos sumergiremos en el fascinante mundo de TypeScript. Veremos los conceptos esenciales, desde los tipos de datos y variables hasta las funciones y par√°metros. Exploraremos el uso de interfaces y tipos personalizados, y profundizaremos en las clases y la herencia. Tambi√©n aprenderemos sobre los m√≥dulos y namespaces, y exploraremos anotaciones de tipo avanzadas para casos especiales. ¬°Prep√°rate para un recorrido completo por TypeScript, donde te proporcionaremos ejemplos sencillos y pr√°cticos para cada tema!

## TEMAS A TRATAR

### Temas completados
- üìò Tipado en typescript
- üìò Modificadores de acceso
- üìò Inmutabilidad
- üìò Herencia

### Temas pendientes
- üìï Composici√≥n
- üìï Dependencia ocultas
- üìï Getter y Setter
- üìï Protected
- üìï Interfaces
- üìï Helpers en interfaces
- üìï Tipos
- üìï Tipos vs Interfaces
- üìï Union de interfaces
- üìï Gen√©ricos

### Tipado en typescript

La adici√≥n del tipado est√°tico en TypeScript proporciona varios beneficios significativos. En primer lugar, nos permite detectar y corregir errores en tiempo de compilaci√≥n en lugar de tiempo de ejecuci√≥n, lo que resulta en un c√≥digo m√°s robusto y confiable. Adem√°s, el tipado est√°tico mejora la legibilidad del c√≥digo, ya que los tipos de datos esperados est√°n expl√≠citamente declarados.

```ts:tipado.ts
let edad: number;
edad = 25; // ‚úÖ Correcto
edad = 'treinta'; // ‚ùå Type 'string' is not assignable to type 'number'
```
En este ejemplo, declaramos una variable llamada "edad" y le asignamos el tipo "number". Esto significa que la variable "edad" solo puede contener valores num√©ricos. Si intentamos asignarle una cadena de texto como 'treinta', el compilador de TypeScript nos mostrar√° un error de compilaci√≥n, ya que el tipo de dato es incorrecto.

#### Tipos impl√≠citos y expl√≠citos

En TypeScript, los tipos pueden ser impl√≠citos o expl√≠citos. Los tipos impl√≠citos son inferidos por el compilador de TypeScript en funci√≥n del valor asignado a la variable, mientras que los tipos expl√≠citos son declarados directamente por el programador.

```ts:impl√≠cito.ts
let nombre = 'Juan'; // El tipo de dato se infiere como string autom√°ticamente
let edad = 25; // El tipo de dato se infiere como number autom√°ticamente

nombre = 'Pedro'; // ‚úÖ Correcto
edad = 30; // ‚úÖ Correcto

nombre = 100; // ‚ùå Type 'number' is not assignable to type 'string'
edad = 'treinta'; // ‚ùå Type 'string' is not assignable to type 'number'
```

En este ejemplo, las variables nombre y edad se declaran sin especificar expl√≠citamente su tipo. El compilador de TypeScript infiere autom√°ticamente el tipo de dato en funci√≥n del valor asignado a cada variable.

En este caso, la variable nombre se infiere como string debido a que se le asigna un valor de texto. La variable edad se infiere como number debido a que se le asigna un valor num√©rico.

>  Es importante tener en cuenta que el tipado expl√≠cito puede ser necesario en situaciones donde la inferencia de tipo no es suficiente o cuando se desea claridad adicional en el c√≥digo.

#### Uso de tipos b√°sicos en TypeScript

En TypeScript, se incluyen varios tipos b√°sicos que nos permiten definir el tipo de datos de variables y expresiones en nuestro c√≥digo. Algunos de los tipos b√°sicos m√°s comunes son:

- number: representa valores num√©ricos, ya sean enteros o decimales.

```ts:number.ts
let edad: number;
edad = 25; // ‚úÖ Correcto
edad = 25.5; // ‚úÖ Correcto
edad = 'treinta'; // ‚ùå Type 'string' is not assignable to type 'number'
```

- string: representa valores de texto o cadenas de caracteres.

```ts:string.ts
let nombre: string;
nombre = 'Juan'; // ‚úÖ Correcto
nombre = 'Pedro'; // ‚úÖ Correcto
nombre = 100; // ‚ùå Type 'number' is not assignable to type 'string'
```

- boolean: representa valores de verdadero o falso.

```ts:boolean.ts
let esMayor: boolean;
esMayor = true; // ‚úÖ Correcto
esMayor = false; // ‚úÖ Correcto
esMayor = 'verdadero'; // ‚ùå Type 'string' is not assignable to type 'boolean'
```
- tuple: representa una colecci√≥n de elementos de diferentes tipos con una longitud fija. Cada elemento del tuple tiene un tipo espec√≠fico y se accede a ellos por su posici√≥n.

```ts:tuple.ts
let persona: [string, number];
persona = ['Juan', 25]; // ‚úÖ Correcto
persona = [25, 'Juan']; // ‚ùå Type 'number' is not assignable to type 'string'
persona = ['Juan', 25, true]; // ‚ùå Type 'boolean' is not assignable to type 'string | number'
```

- enum: permite definir un conjunto de valores con nombres m√°s descriptivos. Cada valor del enum tiene un nombre y un valor num√©rico asociado.

```ts:enum.ts
enum Color {
  Rojo,
  Verde,
  Azul,
}

let color: Color;
color = Color.Rojo; // ‚úÖ Correcto
color = Color.Verde; // ‚úÖ Correcto
color = Color.Azul; // ‚úÖ Correcto
color = 'Rojo'; // ‚ùå Type '"Rojo"' is not assignable to type 'Color'

color = 0; // ‚úÖ Correcto
color = 1; // ‚úÖ Correcto
color = 2; // ‚úÖ Correcto
color = 3; // ‚ùå Type '3' is not assignable to type 'Color'
```

> Se le puede asignar un valor num√©rico a cada elemento del enum, pero si no se especifica, el valor num√©rico se asigna autom√°ticamente en orden ascendente, comenzando desde cero.

- any: representa cualquier tipo de dato, incluidos los tipos primitivos y los tipos de objetos.

```ts:any.ts
let edad: any;
edad = 25; // ‚úÖ Correcto
edad = 'treinta'; // ‚úÖ Correcto
edad = true; // ‚úÖ Correcto
```

> El tipo any es √∫til cuando no se conoce el tipo de dato que se asignar√° a una variable o cuando se desea deshabilitar el tipado est√°tico en un fragmento de c√≥digo. Tener cuidado con el uso del tipo any, ya que puede conducir a errores dif√≠ciles de detectar.

#### null y undefined

En TypeScript, los valores null y undefined tambi√©n tienen sus propios tipos, llamados null y undefined respectivamente. Estos tipos son √∫tiles para representar valores que pueden estar ausentes.

```ts:null.ts
let nombre: string;
nombre = null; // ‚úÖ Correcto
nombre = undefined; // ‚úÖ Correcto

let edad: number;
edad = null; // ‚úÖ Correcto
edad = undefined; // ‚úÖ Correcto
```

## Modificadores de acceso

Los modificadores de acceso en TypeScript permiten controlar la visibilidad y accesibilidad de los miembros de una clase. Aqu√≠ tienes una explicaci√≥n de los tres modificadores de acceso disponibles: public, private y protected.

### public:
Es el modificador de acceso por defecto en TypeScript. Los miembros marcados como `public` son accesibles desde cualquier lugar, tanto desde dentro de la clase como desde instancias de la clase.

```ts:public.ts
class Persona {
  public nombre: string;
  public edad: number;

  constructor(nombre: string, edad: number) {
    this.nombre = nombre;
    this.edad = edad;
  }
}

const persona = new Persona('Juan', 25);
console.log(persona.nombre); // ‚úÖ Correcto
console.log(persona.edad); // ‚úÖ Correcto
```
### private:
Los miembros marcados como `private` son accesibles √∫nicamente desde dentro de la clase donde se definen. No se pueden acceder a ellos desde instancias de la clase ni desde clases heredadas.

```ts:private.ts
class Persona {
  private nombre: string;
  public edad: number;

  constructor(nombre: string, edad: number) {
    this.nombre = nombre;
    this.edad = edad;
  }
}

const persona = new Persona('Juan', 25);
console.log(persona.nombre); // ‚ùå Property 'nombre' is private and only accessible within class 'Persona'
console.log(persona.edad); // ‚úÖ Correcto
```

### protected:
Los miembros marcados como `protected` son accesibles desde dentro de la clase donde se definen y desde clases heredadas. No se pueden acceder a ellos desde instancias de la clase.

```ts:protected.ts
class User {
  userId: string = "f2ecb30c-4c85-4a98-9dd7-357f27b7e343";
  protected password: string = "8MI81Y9zFN%!";
}

class UserDeveloper extends User {
  getUserId() {
    return this.userId;
  }

  compare(password: string) {
    this.match(password, this.password);
  }

  private match(password: string, passwordCipher: string) {
    return false;
  }
}

const userDeveloper = new UserDeveloper();
console.log(userDeveloper.getUserId());
console.log(userDeveloper.userId); // ‚ùå Property 'userId' is protected and only accessible within class 'User' and its subclasses.

const isMatch = userDeveloper.compare("8MI81Y9zFN%!");
console.log(isMatch); // Output: true
```
En este ejemplo, la clase User tiene una propiedad userId y una propiedad protegida password. La clase UserDeveloper hereda de User y puede acceder al miembro protegido userId a trav√©s del m√©todo getUserId(). Sin embargo, al intentar acceder directamente a userId desde fuera de la clase User y sus subclases, se obtiene un error.

La funci√≥n compare en UserDeveloper llama a la funci√≥n privada match, que compara la contrase√±a proporcionada con la contrase√±a protegida. En este caso, se devuelve un valor booleano que indica si las contrase√±as coinciden.

> Los modificadores de acceso nos permiten establecer los niveles de encapsulamiento adecuados en nuestras clases, protegiendo la integridad y la coherencia de los datos.

## Inmutabilidad

 Se refiere a la incapacidad de modificar un objeto una vez que ha sido creado. En TypeScript, podemos lograr la inmutabilidad de diferentes maneras. Aqu√≠ hay algunas t√©cnicas comunes:

 ### Uso de readonly:
 Al marcar una propiedad como readonly, se impide que se modifique despu√©s de la inicializaci√≥n.

 ```ts:readonly.ts
class Persona {
  readonly nombre: string;
  readonly edad: number;

  constructor(nombre: string, edad: number) {
    this.nombre = nombre;
    this.edad = edad;
  }
}

const persona = new Persona('Juan', 25);
persona.nombre = 'Pedro'; // ‚ùå Cannot assign to 'nombre' because it is a read-only property
persona.edad = 30; // ‚ùå Cannot assign to 'edad' because it is a read-only property
```
> Es importante tener en cuenta que el modificador readonly solo se aplica a la propiedad en s√≠, no a su valor. Por ejemplo, si una propiedad es de tipo objeto, el objeto en s√≠ puede modificarse, pero no se puede asignar un nuevo objeto a la propiedad.

```ts:readonly.ts
class Persona {
  readonly nombre: string;
  readonly edad: number;
  readonly direccion: { calle: string; ciudad: string };

  constructor(nombre: string, edad: number, direccion: { calle: string; ciudad: string }) {
    this.nombre = nombre;
    this.edad = edad;
    this.direccion = direccion;
  }
}

const persona = new Persona('Juan', 25, { calle: 'Calle 1', ciudad: 'Ciudad 1' });
persona.nombre = 'Pedro'; // ‚ùå Cannot assign to 'nombre' because it is a read-only property
persona.edad = 30; // ‚ùå Cannot assign to 'edad' because it is a read-only property
persona.direccion.calle = 'Calle 2'; // ‚úÖ Correcto
persona.direccion.ciudad = 'Ciudad 2'; // ‚úÖ Correcto
persona.direccion = { calle: 'Calle 3', ciudad: 'Ciudad 3' }; // ‚ùå Cannot assign to 'direccion' because it is a read-only property
```

### Uso de const
Al declarar una variable con const, se crea una asignaci√≥n de solo lectura. Esto es √∫til para declarar constantes que no deben cambiar.

```ts:const.ts
const nombre = 'Juan';
nombre = 'Pedro'; // ‚ùå Cannot assign to 'nombre' because it is a constant
```

> const crea una asignaci√≥n de solo lectura, lo cual impide la reasignaci√≥n de la variable o constante a un nuevo valor. Para los valores primitivos, el valor en s√≠ es inmutable. En el caso de los objetos, la asignaci√≥n de solo lectura se aplica a la referencia del objeto, pero las propiedades internas del objeto pueden ser modificadas.

```ts:const.ts
const persona = {
  nombre: 'Juan',
  edad: 25,
};

persona.nombre = 'Pedro'; // ‚úÖ Correcto
persona.edad = 30; // ‚úÖ Correcto
persona = { nombre: 'Pedro', edad: 30 }; // ‚ùå Cannot assign to 'persona' because it is a constant
```


### Clonaci√≥n e inmutabilidad:
En ocasiones, es necesario crear copias inmutables de objetos existentes. Esto se puede lograr mediante t√©cnicas de clonaci√≥n, como el uso de la funci√≥n Object.assign() o el operador de propagaci√≥n (...).

```ts:clonaci√≥n.ts
const persona = {
  nombre: 'Juan',
  edad: 25,
  direccion: {
    calle: 'Calle 1',
    ciudad: 'Ciudad 1',
  },
};

const personaClonada = Object.assign({}, persona);
personaClonada.nombre = 'Pedro'; // ‚úÖ Correcto
personaClonada.edad = 30; // ‚úÖ Correcto
personaClonada.direccion.calle = 'Calle 2'; // ‚úÖ Correcto
personaClonada.direccion.ciudad = 'Ciudad 2'; // ‚úÖ Correcto

console.log(persona.nombre); // ‚úÖ Correcto
console.log(persona.edad); // ‚úÖ Correcto
console.log(persona.direccion.calle); // ‚úÖ Correcto
console.log(persona.direccion.ciudad); // ‚úÖ Correcto
```

### Uso de Object.freeze()
La funci√≥n Object.freeze() se puede utilizar para crear objetos inmutables. Esto evita que se agreguen, eliminen o modifiquen propiedades de un objeto existente.

```ts:freeze.ts
const persona = {
  nombre: 'Juan',
  edad: 25,
  direccion: {
    calle: 'Calle 1',
    ciudad: 'Ciudad 1',
  },
};

Object.freeze(persona);
persona.nombre = 'Pedro'; // ‚ùå Cannot assign to 'nombre' because it is a read-only property
persona.edad = 30; // ‚ùå Cannot assign to 'edad' because it is a read-only property
persona.direccion.calle = 'Calle 2'; // ‚ùå Cannot assign to 'calle' because it is a read-only property

```


## Herencia

La herencia es un concepto fundamental en la programaci√≥n orientada a objetos que permite crear jerarqu√≠as de clases, donde las clases hijas heredan propiedades y comportamientos de una clase padre.

En TypeScript, la herencia se logra utilizando la palabra clave extends. Una clase hija hereda los miembros (propiedades y m√©todos) de la clase padre y puede agregar nuevos miembros o modificar los existentes.

```ts:herencia.ts
class Animal {
  nombre: string;
  constructor(nombre: string) {
    this.nombre = nombre;
  }

  saludar() {
    console.log(`Hola, soy ${this.nombre}.`);
  }
}

class Perro extends Animal {
  raza: string;
  constructor(nombre: string, raza: string) {
    super(nombre);
    this.raza = raza;
  }

  saludar() {
    console.log(`¬°Guau! Soy ${this.nombre} y soy un perro de raza ${this.raza}.`);
  }

  ladrar() {
    console.log("¬°Guau! ¬°Guau!");
  }
}

const miPerro = new Perro("Max", "Labrador");
miPerro.saludar(); // Output: ¬°Guau! Soy Max y soy un perro de raza Labrador.
miPerro.ladrar(); // Output: ¬°Guau! ¬°Guau!

const miAnimal = new Animal("Max");
miAnimal.saludar(); // Output: Hola, soy Max.
miAnimal.ladrar(); // ‚ùå Property 'ladrar' does not exist on type 'Animal'.
```
En este ejemplo, la clase Animal es la clase padre y define una propiedad nombre y un m√©todo saludar(). La clase Perro es la clase hija que extiende de Animal utilizando extends. La clase Perro a√±ade una propiedad raza y sobrescribe el m√©todo saludar() para agregar informaci√≥n adicional.

Al crear una instancia de Perro y llamar a los m√©todos, se puede observar c√≥mo se heredan tanto la propiedad nombre como el m√©todo saludar() de la clase Animal. Adem√°s, la clase Perro puede agregar su propio m√©todo ladrar().

Sin embargo, al crear una instancia de Animal, no se puede acceder al m√©todo ladrar(), ya que la clase Animal no tiene este m√©todo.

Diagrama de clase de herencia

```
                +--------------+
                |   Animal     |
                +--------------+
                | - nombre     |
                +--------------+
                | + constructor|
                | + saludar()  |
                +--------------+
                       ^
                       |
                +--------------+
                |    Perro     |
                +--------------+
                | - raza       |
                +--------------+
                | + constructor|
                | + saludar()  |
                | + ladrar()   |
                +--------------+
```
#### Super
La palabra clave super se utiliza para acceder a los miembros de la clase padre desde una clase hija. Se puede utilizar para llamar al constructor de la clase padre o para llamar a los m√©todos de la clase padre.

> La herencia permite reutilizar c√≥digo, organizar jerarqu√≠as de clases y especializar comportamientos. Las clases hijas pueden acceder a los miembros heredados utilizando `super` y tambi√©n pueden agregar nuevos miembros propios.

```ts:super.ts
class Vehiculo {
  marca: string;

  constructor(marca: string) {
    this.marca = marca;
  }

  acelerar() {
    console.log(`El veh√≠culo de marca ${this.marca} est√° acelerando.`);
  }
}

class Auto extends Vehiculo {
  modelo: string;

  constructor(marca: string, modelo: string) {
    super(marca);
    this.modelo = modelo;
  }

  acelerar() {
    super.acelerar(); // Llama al m√©todo 'acelerar()' de la clase padre
    console.log(`El auto de modelo ${this.modelo} tambi√©n est√° acelerando.`);
  }
}

const miAuto = new Auto("Toyota", "Camry");
miAuto.acelerar();
```

En este ejemplo, la clase Vehiculo es la clase padre que tiene una propiedad marca y un m√©todo `acelerar()`. La clase Auto es la clase hija que extiende de Vehiculo y agrega una propiedad modelo.

Dentro del constructor de la clase Auto, se utiliza `super(marca)` para llamar al constructor de la clase padre y pasarle el argumento marca. Esto asegura que la propiedad marca de la clase padre se inicialice correctamente.

Luego, en el m√©todo `acelerar()` de la clase Auto, se utiliza `super.acelerar()` para llamar al m√©todo `acelerar()` de la clase padre. Esto permite ejecutar el c√≥digo del m√©todo de la clase padre y luego agregar la l√≥gica adicional espec√≠fica de la clase Auto.

Al crear una instancia de Auto y llamar al m√©todo `acelerar()`, se ver√° la salida de ambos mensajes: el mensaje del m√©todo `acelerar()` de la clase Vehiculo y el mensaje espec√≠fico del m√©todo `acelerar()` de la clase Auto.

### Herencia m√∫ltiple

La herencia m√∫ltiple es una caracter√≠stica de la programaci√≥n orientada a objetos que permite que una clase herede de m√∫ltiples clases. En TypeScript, la herencia m√∫ltiple se logra utilizando la palabra clave implements.

```ts:herencia-multiple.ts
class Animal {
  nombre: string;
  constructor(nombre: string) {
    this.nombre = nombre;
  }

  saludar() {
    console.log(`Hola, soy ${this.nombre}.`);
  }
}

class Mascota {
  dueno: string;
  constructor(dueno: string) {
    this.dueno = dueno;
  }

  mostrarDueno() {
    console.log(`Mi due√±o es ${this.dueno}.`);
  }
}

class Perro implements Animal, Mascota {
  nombre: string;
  dueno: string;
  constructor(nombre: string, dueno: string) {
    this.nombre = nombre;
    this.dueno = dueno;
  }

  saludar() {
    console.log(`¬°Guau! Soy ${this.nombre} y mi due√±o es ${this.dueno}.`);
  }

  mostrarDueno() {
    console.log(`Mi due√±o es ${this.dueno}.`);
  }

  ladrar() {
    console.log("¬°Guau! ¬°Guau!");
  }
}

const miPerro = new Perro("Max", "Juan");
miPerro.saludar(); // Output: ¬°Guau! Soy Max y mi due√±o es Juan.
miPerro.mostrarDueno(); // Output: Mi due√±o es Juan.
miPerro.ladrar(); // Output: ¬°Guau! ¬°Guau!
```







