---
title: "Mi primera aplicaci√≥n con Three.js y React"
summary: "Tutorial b√°sico de Three.js dentro del entorno de React.js"
cover: "https://res.cloudinary.com/lambda-ingenier-a-e-innovaci-n/image/upload/v1665983632/blog-Riverscode/Asincronismo-portada_dp7jbz.png"
author: "Rivers Code"
publishedAt: "2022-11-21"
image: "threejs.webp"
tags:
  - "üíª Three.js "
  - "‚öõ React.js"
references:
    link: "https://www.youtube.com/watch?v=bMknfKXIFA8"
status: "ready"
---

## Introducci√≥n

En este tutorial vamos a aprender los fundamentos de Three.js, una librer√≠a de JavaScript que nos permite crear gr√°ficos 3D en la web. Para ello vamos a utilizar React.js como entorno de desarrollo.

## Agenda

- üíª Agregar Three.js a nuestro proyecto
- ‚ú® useRef para referenciar nuestro renderizado
- üîÆ Crear una escena
- üì∏ Crear una c√°mara
- üé® Crear un renderizador
- üé≤ Crear un mesh
- üö´ Solucionar problemas comunes

## Tutorial

### üíª Agregar Three.js a nuestro proyecto

Lo primero que haremos es instalar three.js dentro de nuestro proyecto y esto lo podemos hacer usando npm.

```bash
npm install three
```

Crearemos un archivo Sceme.js dentro de la carpeta üìÅcomponents que ser√° el encargado de manejar todo lo relacionado con Three.js.

```jsx:Sceme.jsx
const Scene = () => {
  return <div className=" w-full h-screen">
    <h1>Aqu√≠ Montaremos nuestro contenido 3D</h1>
  </div>;
};
export default Scene;

```

> En este caso estamos manejando Tailwindcss para los estilos. Podemos revisar la pagina oficial de Tailwindcss y en parte de integraci√≥n seguir los pasos de [integraci√≥n con Vite](https://tailwindcss.com/docs/guides/vite)

Ahora importemos este componente en App.js

```jsx:App.js
import Scene from "./components/Scene";
function App() {
  return (
    <div className="App">
      <Scene />
    </div>
  );
}
export default App;
```

### ‚ú® useRef para referenciar nuestro renderizado

Ya que hemos importado nuestro componente Scene, ahora vamos a usar el hook **useRef** que nos permita manejar el canvas de Three.js. Adem√°s, vamos a usar el hook **useEffect** para que se ejecute una sola vez y no se vuelva a ejecutar.


```jsx:Sceme.jsx
import { useEffect, useRef } from "react";
import * as THREE from "three";

const Scene = () => {
  const canvasRef = useRef();
  useEffect(() => {
    const currentCanvas = canvasRef.current;

    // #### C√≥digo de Three.js ####

  }, []);

  return (
    <div className=" w-full h-screen" ref={canvasRef}>
    </div>
  );
};
export default Scene;
```

### üîÆ Crear nuestra escena

Ahora vamos a crear nuestra escena, para ello vamos a crear una constante llamada **[scene](https://threejs.org/docs/#api/en/scenes/Scene)** y le asignaremos una nueva instancia de **THREE.Scene()**.

```jsx:Sceme.jsx
// Las escenas le permiten configurar qu√© y d√≥nde se renderizar√° con three.js.
// Aqu√≠ es donde colocas objetos, luces y c√°maras.
const scene = new THREE.Scene();

```

### üì∏ Crear nuestra c√°mara

Ahora vamos a crear nuestra c√°mara, para ello vamos a crear una constante llamada **camera** y le asignaremos una nueva instancia de **[THREE.PerspectiveCamera()](https://threejs.org/docs/#api/en/cameras/PerspectiveCamera)**.

```jsx:Sceme.jsx
const camera = new THREE.PerspectiveCamera(
  75, // Campo de visi√≥n
  window.innerWidth / window.innerHeight, // Relaci√≥n de aspecto
  0.1, // Plano cercano
  1000 // Plano lejano
);

```

Tambi√©n tenemos la opci√≥n de crear una c√°mara ortogr√°fica con **[THREE.OrthographicCamera()](https://threejs.org/docs/?q=camera#api/en/cameras/OrthographicCamera)**.

```jsx:Sceme.jsx
const camera = new THREE.OrthographicCamera(
  window.innerWidth / -2, // Izquierda
  window.innerWidth / 2, // Derecha
  window.innerHeight / 2, // Arriba
  window.innerHeight / -2, // Abajo
  0.1, // Plano cercano
  1000 // Plano lejano
);
```


Para seguir con nuestro ejemplo en el cual hacemos referencia a un div mediante el **useRef** vamos a definir el window.innerWidth igual a **currentCanvas.clientWidth** y el window.innerHeight igual a **currentCanvas.clientHeight**.

> La **PerspectiveCamera** es la m√°s com√∫n. Simula la visi√≥n humana. La **OrthographicCamera** es una c√°mara ortogr√°fica. No simula la visi√≥n humana, pero es √∫til para renderizar objetos 2D.

![Three.js - PerspectiveCamera vs OrthographicCamera](https://i.stack.imgur.com/6ZfBu.png)

### üé® Crear nuestro renderizador

Ahora vamos a crear nuestro renderizador, para ello vamos a crear una constante llamada **renderer** y le asignaremos una nueva instancia de **[THREE.WebGLRenderer()](https://threejs.org/docs/#api/en/renderers/WebGLRenderer)**.

```jsx:Sceme.jsx
const renderer = new THREE.WebGLRenderer({
  antialias: true, // Suavizado
});
renderer.setSize(currentCanvas.clientWidth, currentCanvas.clientHeight);
```

### Armar todo nuestro renderizador

Ahora vamos a agregar nuestro renderizador al DOM, para ello vamos a crear una constante llamada **currentCanvas** y le asignaremos el valor de **canvasRef.current**.

Posteriormente realizaremos el render de la scenea y la camara.

```jsx:Sceme.jsx
// Agregamos el renderizador al DOM
currentCanvas.appendChild(renderer.domElement);

// Renderizar la escena y la c√°mara
renderer.render(scene, camera);
```

### üé≤ Agregaremos un Mesh

Ahora vamos a agregar un Mesh, para formar un Mesh es necesario formarlo a partir de dos elementos principales. El primero es un **[Geometry](https://threejs.org/docs/#api/en/core/Geometry)** y el segundo es un **[Material](https://threejs.org/docs/#api/en/materials/Material)**.

```jsx:Sceme.jsx
const cube = new THREE.BoxGeometry(1, 1, 1); // Geometr√≠a del cubo (ancho, alto, profundidad)
const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // Material del cubo (color)
const mesh = new THREE.Mesh(cube, material); // Mesh (geometr√≠a, material)
scene.add(mesh); // Agregamos el mesh a la escena
```

>Podr√≠amos hacer una analog√≠a diciendo que la geometr√≠a es el esqueleto y el material es la piel. En este caso estamos usando un [MeshBasicMaterial](https://threejs.org/docs/?q=MeshBasicMaterial#api/en/materials/MeshBasicMaterial) que es un material b√°sico que no se ve afectado por la luz.

### üö´ Solucionar problemas de la c√°mara.

Si nosotros verificamos actualmente el renderizado en nuestro navegador nos daremos con la sorpresa que nuestro cubo no se ve. Esto se debe a que la c√°mara se encuentra en el mismo lugar que el cubo. Para solucionar esto vamos a mover la c√°mara 5 unidades en el eje Z.

```jsx:Sceme.jsx
// Cambiar posici√≥n unicamente en z
camera.position.z = 5;

// Cambiar posici√≥n en x y z
camera.position.set(0,0,5);
```

### üö´ Solucionando problemas de useEffect

Si verificamos el DOM de nuestro navegador nos daremos con la sorpresa que existen m√°s de un canvas. Esto se debe al funcionamiento del **useEffect** que se ejecuta cada vez que se renderiza el componente. Para solucionar esto vamos a agregar un **return** en nuestro **useEffect**.

```jsx:Sceme.jsx
useEffect(() => {
  // #### C√≥digo Three.js ####

  return () => {
    currentCanvas.removeChild(renderer.domElement);
  }
}, []);
```

Finalmente hemos creado nuestro primer proyecto en React.js usando la librer√≠a Three.js. Te invito a que continues con los siguientes tutoriales dado que veremos temas relacionados con las colores, luces, texturas, animaciones, etc.


Espero que les sirva el peque√±o tutorial sobre como crear. ¬øC√≥mo apoyarme a seguir creando contenido? simplemente compartan el art√≠culo, s√≠ganme en [YouTube](https://www.youtube.com/c/RiversCode), [Instagram](https://www.instagram.com/rivers_code/) y [Facebook](https://www.facebook.com/LambdaInnovacion/).