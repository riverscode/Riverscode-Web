---
title: "Entender el Asincronismo en Javascript"
summary: "La cl谩sica pregunta de diferencias entre Callbacks, Promesas y Async/Await"
cover: "https://res.cloudinary.com/lambda-ingenier-a-e-innovaci-n/image/upload/v1665983632/blog-Riverscode/Asincronismo-portada_dp7jbz.png"
author: "Rivers Code"
publishedAt: "2022-10-17"
image: "javascript.png"
tags:
  - " Javascript"
references:
    link: "https://www.youtube.com/watch?v=bMknfKXIFA8"
status: "ready"
---

Una de las preguntas cl谩sicas en una entrevista de trabajo sobre frontend, sin importar que frameworks o librer铆as se usen, es la diferencia entre Callbacks, Promesas y Async/Await. 驴Cu谩l es mejor? 驴Porque usar una u otra? Es pr谩cticamente una pregunta que la tienen preparada para el entrevistado.

Este art铆culo trata de explicar de una manera sencilla y pr谩ctica, que es lo que hacen cada una de estas formas de manejar el asincronismo en JavaScript. Haremos ejemplos para poder entender al fin que es lo que hacen y como se usan.

## Asincronismo

Antes de iniciar con el camino de los callbacks, promesas y Async/Await es necesario entender el concepto de asincronismo. Iniciemos primero con entender que es el sincronismo en los lenguajes de programaci贸n. 

> **El sincronismo** es cuando un programa se ejecuta l铆nea por l铆nea, es decir, que cada l铆nea de c贸digo se ejecuta una despu茅s de la otra. 

El asincronismo es una caracter铆stica de JavaScript que nos permite ejecutar c贸digo de manera no secuencial, es decir, que podemos ejecutar c贸digo que no depende de que el c贸digo anterior se haya ejecutado. Esto nos permite hacer cosas como hacer peticiones a un servidor, esperar a que el usuario haga click en un bot贸n, o esperar a que el usuario escriba algo en un input.

Entonces podemos decir que JavaScript es un lenguaje de programaci贸n asincrono, ya que nos permite ejecutar c贸digo de manera no secuencial. La respuesta es no, ya que la definici贸n correcta de javascript es que es un lenguaje de programaci贸n sincrono por defecto y no bloqueante utilizando un 煤nico subproceso, con un bucle de eventos **(Concurrencia)**.

La palabra clave en el anterior es **no es bloqueante**. Esto quiere decir que cuando ejecutamos c贸digo que puede tardar un tiempo, no bloqueamos el hilo principal de ejecuci贸n, es decir, que podemos seguir ejecutando c贸digo mientras esperamos a que el c贸digo que se esta ejecutando termine.

Otro concepto que vamos encontrar es que JavaScript tiene un 煤nico hilo principal de ejecuci贸n **(Single Thread)**. Esto quiere decir que JavaScript no puede ejecutar dos cosas a la vez, es decir, que no podemos ejecutar dos funciones a la vez.

## Concurrencia en JavaScript

La concurrencia es la capacidad de ejecutar multiples tareas al mismo tiempo. JavaScript es un lenguaje de programaci贸n que es concurrencia, ya que podemos ejecutar multiples tareas al mismo tiempo. Esto quiere decir que podemos ejecutar multiples funciones al mismo tiempo, pero no podemos ejecutar dos funciones al mismo tiempo, en caso una tarea demore m谩s de lo debido haremos la siguiente esperando que la otra se maneje.

JavaScript maneja la concurrencia mediante un bucle de eventos. Este bucle de eventos (event loop) es un bucle que se ejecuta constantemente, y que se encarga de ejecutar las funciones que se encuentran en la cola de tareas. Este bucle de eventos se ejecuta constantemente, y se encarga de ejecutar las funciones que se encuentran en la cola de tareas. Este bucle de eventos se ejecuta constantemente, y se encarga de ejecutar las funciones que se encuentran en la cola de tareas.

![EventLoop](https://res.cloudinary.com/lambda-ingenier-a-e-innovaci-n/image/upload/v1665886661/blog-Riverscode/EventLoop_vlabdp.png)

## Callbacks

Una funci贸n de callback es una funci贸n que se pasa a otra funci贸n como un argumento, que luego se invoca dentro de la funci贸n externa para completar alg煤n tipo de rutina o acci贸n (mdn web docs) 

```js:callbacks.js
function UseHability(fruitName) {
  console.log(`Puedes usar el poder de ${fruitName}`);
}

function EatFruit(fruitName, callback) {
  console.log(`He comido la fruta ${fruitName}`);
  callback();
}

EatFruit("mera mera no mi", UseHability);
```

Lo que podemos ver es que podemos manejar el asincronismo en JavaScript mediante funciones de callback. En este ejemplo tenemos una funci贸n que se llama EatFruit, que recibe dos par谩metros, el nombre de la fruta y una funci贸n de callback. Dentro de la funci贸n EatFruit, ejecutamos la funci贸n que recibimos como par谩metro, y le pasamos el nombre de la fruta como par谩metro.


```js:callbacks.js
function UseHability(fruitName) {
  console.log(`Puedes usar el poder de ${fruitName}`);
}

function EatFruit(fruitName, callback) {
  console.log(`He comido la fruta ${fruitName}`);
  setTimeout(callback, 2000);
}
```

En este ejemplo podemos ver que la funci贸n de callback se ejecuta despu茅s de 2 segundos. Esto es debido a que la funci贸n setTimeout, nos permite ejecutar una funci贸n despu茅s de un tiempo determinado. En este caso, la funci贸n setTimeout, nos permite ejecutar la funci贸n de callback despu茅s de 2 segundos.

> No es recomendable usar funciones de callback para manejar el asincronismo en JavaScript, ya que puede llegar a ser muy complicado de entender y mantener. Puede generar el famoso **callback hell que es un problema que se presenta cuando tenemos multiples funciones de callback anidadas**.

## Promesas 

Las promesas son un objeto que representa la terminaci贸n o el fracaso eventual de una operaci贸n as铆ncrona. Una promesa puede estar en uno de tres estados: pendiente, cumplida o rechazada. 

- **Pending:** Estado inicial, ni cumplido ni rechazado.
- **Fulfilled:** Lo que significa que la operaci贸n se complet贸 con 茅xito.
- **Rejected:** Lo que significa que la operaci贸n fall贸.

Cuando tenemos una promesa, tenemos dos opciones de resultados. Puede retornar un valor en caso la promesa se resuelva con 茅xito o nos puede retorna un error en caso la promesa falle. Para manejar estos resultados lo podemos hacer mediante los controladores then y catch.

Utilizamos then cuando queremos manejar el resultado de una promesa que se resolvi贸 con 茅xito. Utilizamos catch cuando queremos manejar el resultado de una promesa que fallo.

El m茅todo ```.then()```  toma hasta dos argumentos; el primer argumento es una funci贸n de devoluci贸n de llamada **(callback)** para el caso resuelto de la promesa, y el segundo argumento es una funci贸n de devoluci贸n de llamada para el caso rechazado.

```js:promises.js
function EatFruit(fruitName) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (fruitName === "mera mera no mi") {
        resolve(`Puedes usar el poder de ${fruitName}`);
      } else {
        reject("Usted no es un pirata");
      }
    }, 2000);
  });
}
```

Aqu铆 vemos un ejemplo de una promesa. En este ejemplo tenemos una funci贸n que se llama EatFruit, que recibe un par谩metro que es el nombre de la fruta. Esta funci贸n retorna una promesa, y esta promesa recibe dos par谩metros, resolve y reject. Estos par谩metros son funciones que podemos llamar para resolver o rechazar la promesa. En este ejemplo, si el nombre de la fruta es "mera mera no mi", resolvemos la promesa con el nombre de la fruta, y si no es "mera mera no mi", rechazamos la promesa con un mensaje de error.

> Las promesas nos permiten manejar el asincronismo de una forma m谩s sencilla y legible. **Fueron introducidas en ES6, y son una mejora de los callbacks.**

## Async/Await 

Iniciemos diciendo que **Async/Await** es considerado un az煤car sint谩ctico de las promesas. Esto quiere decir que cuando usamos async/await, estamos usando promesas solo que de una manera mas "Sencilla" con el objetivo de evitarnos usar ```then()``` y ```catch()```. 

```js:async-await.js
function EatFruit(fruitName) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (fruitName === "mera mera no mi") {
        resolve(`Puedes usar el poder de ${fruitName}`);
      } else {
        reject("Usted no es un pirata");
      }
    }, 2000);
  });
}

async function UseHability() {
  try {
    const result = await EatFruit("mera mera no mi");
    console.log(result);
  } catch (error) {
    console.log(error);
  }
}

UseHability();
```

En el ejemplo anterior hemos creado dos funciones. La primera funci贸n, EatFruit, retorna una promesa donde manejamos el asincronismo con los par谩metros resolve y reject. La segunda funci贸n, UseHability, es una funci贸n asincr贸nica, y dentro de esta funci贸n, utilizamos la palabra reservada await, para esperar a que la promesa se resuelva. Cuando la promesa se resuelve, la funci贸n UseHability, imprime el resultado de la promesa. Si la promesa falla, la funci贸n UseHability, imprime el error de la promesa.

Cuando us谩bamos promesas, ten铆amos la posibilidad de manejar el error con el segundo par谩metro de ```then()``` o el uso directo de ```catch()```. Con async/await, podemos los errores dentro de un bloque try/catch.  


> La llegada de Async y Await a JavaScript **fue una de las grandes novedades de ES2017**. Al igual que las promesas permite manejar el asincronismo de una forma m谩s sencilla y legible.





